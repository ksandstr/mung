#!/usr/bin/perl
use strict;
use warnings;
use utf8;
use feature "switch";

use FindBin qw($Bin);
use lib "$Bin/perl5";

use IO::File;
use IO::Pipe;
use TryCatch;
use List::Util qw/sum/;
use List::MoreUtils qw/none/;

use Mung::Sink;
use Mung::Test;
use Mung::TestResult;
use Mung::TapError;
use Mung::ConsoleReport;
use Mung::Error::TestAbort;
use Mung::Error::TestRestart;


my $TOPLEVEL = ".";
-f "$TOPLEVEL/run.sh" || die "can't find run.sh in path `$TOPLEVEL'";

$SIG{PIPE} = "IGNORE";		# and smoke it.
$SIG{INT} = "IGNORE";		# my regards to 007
$| = 1;


sub start_test {
	my %opts = @_;

	my @parms;
	foreach(keys %opts) {
		my $key = $_;
		my $val = $opts{$key};
		$val = join("+", @$val) if ref($val) eq 'ARRAY';
		$key =~ s/_//g;
		push @parms, "$key=$val";
	}
	if(@parms) {
		$ENV{TESTBENCH_OPTS} = join(" ", @parms);
	} else {
		delete $ENV{TESTBENCH_OPTS};
	}
	return IO::File->new("./run.sh -display none 2>/dev/null |");
}


my ($suite, $tcase, $test);
# %stats = (
#   failed => integer, # of failed tests in all suites
#   incorrect => integer, # of failed test points in all suites
#   suites => ref to vector of values in $suite
# )

# set of id:iter of completed tests. completion means that the test shouldn't
# be run again.
my %completed;

# printable name of a test. tcase and suite assumed in context.
sub current_test_name {
	my $n = $test->name;
	my $iter = $test->current_result->iter;
	$n .= " {iter $iter}" if $test->low < $test->high;
	return $n;
}


my $i = 0;
my $status = 0;
my @errors;


my $sink = Mung::Sink->new(
	completed_ref => \%completed,
	output => Mung::ConsoleReport->new);
sub report_msg { $sink->print("$_\n") foreach @_; }
my @test_remain;	# [ "$id:$iter", Mung::Test ]
my $prev_restart_id;
do {
	my $test_pipe;
	if(@test_remain) {
		# do up to 80 characters' worth of id:iter pairs at a time.
		my @only;
		my $count = 0;
		for(;;) {
			my ($id, $test_inst) = @{shift @test_remain || last};
			next if $completed{$id};
			my $len = length($id) + ($count > 0 ? 1 : 0);
			last if $count + $len > 80;
			$count += $len;
			push @only, $id;
		}

		$test_pipe = start_test(run_only => \@only);
	} else {
		# initial run, without restart.
		$test_pipe = start_test(describe => 1);
	}

	my $ctl_seen = 0;
	while(<$test_pipe>) {
		chomp;
		s/^\s+//;	# apparently sometimes there are carriage returns.

		if(!$ctl_seen) {
			next unless /^\*\*\*\s/;
			$ctl_seen = 1;
		}

		last if /^\*\*\*.+\bcompleted/;
		try {
			$sink->tb_line($_);
		}
		catch (Mung::Error::TestRestart $exn) {
			my $test = $exn->test;
			my $rest_id = $test->id . ":" . $test->current_result->iter;
			# report_msg("restarting on `$rest_id'.");
			$test->end_test;
			if(defined $prev_restart_id && $prev_restart_id ne $rest_id) {
				# first restart on this ID
				delete $completed{$rest_id};
			} else {
				# would be the second, or was otherwise already the first;
				# skip it and restart from the test after this one.
			}
			$prev_restart_id = $rest_id;

			@test_remain = ();
			while(my ($path, $pt) = each %{$sink->plan}) {
				for(my $i = $pt->low; $i <= $pt->high; $i++) {
					my $n = $pt->id . ":$i";
					push @test_remain, [ $n, $pt ] unless exists $completed{$n};
				}
			}
			# report_msg(scalar(@test_remain) . " tests remain.");

			# stop processing a TAP result.
			undef $suite;

			last;
		}
		catch (Mung::Error $exn) {
			report_msg("test aborted: " . $exn->to_string);
			last;
		}
	}
	kill "INT", -getpgrp(0);
	$test_pipe->close;
} while(@test_remain);

# terminate suite line
print "\n";

# reporting.

# test points that failed, in plan order.
my %notok_suites;
my @out;
foreach my $suite (@{$sink->suites}) {
	foreach my $tcase (@{$suite->tcases}) {
		foreach my $test (@{$tcase->tests}) {
			my @results = @{$test->results};
			next if none { @{$_->not_ok} > 0 } @results;

			my $res = pop @results;
			my $sum = scalar @{$res->not_ok};
			$notok_suites{$suite->{name}} = 1;

			my $tn = $test->name;
			$tn .= ":" . $res->iter if $test->low != $test->high;
			push @out, "Test `$tn' in case `" . $tcase->name
				. "' had $sum failed test point(s):";
			foreach my $p (@{$res->not_ok}) {
				my $report = $p->{report};
				$report =~ s/\[\w+:\w+\]\s?//;
				push @out, "  $p->{id}:\t$report";
			}

			if(@results) {
				# FIXME: report on differing @{$_->not_ok} lists and so forth
				my $times = scalar(@results) + 1;
				push @out, "  (was run $times times total; last reported.)";
			}
		}
	}
}
my $num_notok_suites = scalar(keys %notok_suites);
if($num_notok_suites > 0) {
	print "\n" if @out;
	print "$_\n" foreach(@out);
	print "There were failed test points in $num_notok_suites suite(s).\n";
}

# outputs generated by die() while parsing testbench output
if(@errors) {
	my %bywhat;
	my @what_order;
	foreach(@errors) {
		my $key = $_->{error}->text;
		push @what_order, $key unless exists $bywhat{$key};
		push @{$bywhat{$key}}, $_;
	}

	print "There were " . scalar @errors . " errors parsing test output:\n";
	# (and "scalar @what_order" different kinds of error.)
	foreach my $what (@what_order) {
		print "  $what\n";
		foreach my $err (@{$bywhat{$what}}) {
			print "\tline `$err->{line}'\n";
		}
	}
}

if($sink->incorrect || $sink->failed) {
	print "There were " . $sink->incorrect . " incorrect tests";
	my $f = $sink->failed;
	if($f) {
		print ", and $f test(s) failed";
		$status = 2;
	}
	print ".\n";
}

# exit codes: 1 for premature testbench abort, 2 for test failures.
exit $status;
